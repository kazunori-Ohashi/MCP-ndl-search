import { NaturalLanguageRequest, SearchQueryCandidate } from '../types/contracts';
import { LLMClient } from '../adapters/llm.types';

export interface QueryGeneratorOptions {
  llmClient?: LLMClient;
  maxCandidates?: number;
}

const DEFAULT_MAX_CANDIDATES = 3;

export async function generateQueries(
  request: NaturalLanguageRequest,
  options: QueryGeneratorOptions = {}
): Promise<SearchQueryCandidate[]> {
  const { llmClient, maxCandidates = DEFAULT_MAX_CANDIDATES } = options;
  const { text } = request;

  try {
    // Rule-based extraction (highest priority)
    const ruleBasedCandidates = extractRuleBasedQueries(text, request);
    if (ruleBasedCandidates.length > 0) {
      return ruleBasedCandidates;
    }

    // LLM-based generation (fallback)
    if (llmClient) {
      const llmCandidates = await generateLLMCandidates(text, llmClient, { maxCandidates });
      return filterSafeCandidates(llmCandidates, request);
    }

    return [];
  } catch (error) {
    console.error('Query generation failed:', error);
    return [];
  }
}

function extractRuleBasedQueries(text: string, _request: NaturalLanguageRequest): SearchQueryCandidate[] {
  const candidates: SearchQueryCandidate[] = [];

  // ISBN extraction (highest priority)
  const isbnMatch = extractISBN(text);
  if (isbnMatch) {
    candidates.push({
      cql: `isbn=${isbnMatch}`,
      confidence: 0.99,
      explanation: 'Direct ISBN extraction from input',
      generatedBy: 'rules'
    });
  }

  // Add more rule-based patterns here as needed
  // - ISSN extraction
  // - DOI extraction  
  // - Simple field=value patterns

  return candidates;
}

function extractISBN(text: string): string | null {
  // Remove common prefixes
  const cleanText = text.replace(/isbn[:\s-]*/gi, '');
  
  // Match 13-digit ISBN (978 or 979 prefix)
  const isbn13Match = cleanText.match(/\b(97[89][-]?\d{1}[-]?\d{3}[-]?\d{5}[-]?\d{1})\b/);
  if (isbn13Match) {
    return isbn13Match[1].replace(/-/g, '');
  }

  // Match 10-digit ISBN  
  const isbn10Match = cleanText.match(/\b(\d{1}[-]?\d{3}[-]?\d{5}[-]?[\dX])\b/);
  if (isbn10Match) {
    return isbn10Match[1].replace(/-/g, '');
  }

  // Fallback: look for any sequence of 10 or 13 digits that could be an ISBN
  const digitMatch = text.match(/\b(\d{10}|\d{13})\b/);
  if (digitMatch) {
    const digits = digitMatch[1];
    // Validate 13-digit ISBN starts with 978 or 979
    if (digits.length === 13 && (digits.startsWith('978') || digits.startsWith('979'))) {
      return digits;
    }
    // Return 10-digit as-is
    if (digits.length === 10) {
      return digits;
    }
  }

  return null;
}

async function generateLLMCandidates(
  text: string, 
  llmClient: LLMClient, 
  options: { maxCandidates: number }
): Promise<SearchQueryCandidate[]> {
  try {
    const llmResponse = await llmClient.generateCqlCandidates(text, options);
    
    return llmResponse.map(candidate => ({
      cql: candidate.cql,
      confidence: candidate.confidence ?? 0.5,
      explanation: candidate.explanation ?? 'Generated by LLM',
      generatedBy: 'llm' as const
    }));
  } catch (error) {
    console.error('LLM generation failed:', error);
    return [];
  }
}

function filterSafeCandidates(
  candidates: SearchQueryCandidate[], 
  request: NaturalLanguageRequest
): SearchQueryCandidate[] {
  return candidates
    .filter(candidate => {
      // Filter out wildcard queries
      if (candidate.cql.includes('*')) {
        return false;
      }
      
      // Filter out overly broad queries (low confidence)
      if (candidate.confidence && candidate.confidence < 0.3) {
        return false;
      }

      return true;
    })
    .map(candidate => {
      // Add Japanese language preference if Japanese text detected
      if (hasJapaneseText(request.text) && !candidate.cql.includes('language=')) {
        return {
          ...candidate,
          cql: addLanguageFilter(candidate.cql, 'jpn')
        };
      }
      return candidate;
    });
}

function hasJapaneseText(text: string): boolean {
  // Simple Japanese character detection
  return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text);
}

function addLanguageFilter(cql: string, language: string): string {
  // Add language filter if not already present
  if (cql.includes('AND')) {
    return `${cql} AND language="${language}"`;
  } else {
    return `${cql} AND language="${language}"`;
  }
}